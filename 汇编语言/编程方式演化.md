1. 输入设备中只有一个程序，即目标程序，没有操作系统。程序不是以文件的形式，而是二进制的代码和数据，以约定好的方式和地址存储。程序独占计算机的资源，从开始处被CPU作为指令执行，并一直执行，以死循环或停机指令结束。CPU使用平坦模型，程序对内存的访问是硬编码的，没有经过重定位，程序对数据访问和指令跳转的地址都是已知且固定的。
2. 当修改程序时，程序中数据和指令的位置会发生变化，导致程序中根据地址获取数据、根据地址跳转、根据相对位置跳转的指令需要重新计算位置或位移，很繁琐耗时，容易出错。因此出现了汇编语言，使用各种符号和标记帮助记忆。
汇编语言中可以使用符号标记位置，用来表示符号位置的相对地址，在每次汇编程序的时候会重新计算每个符号的地址， 然后把所有引用到符号的指令修正到正确的地址。
汇编语言中也可以使用section或segment把程序划分成几个部分，并为某部分指定一个起始地址，那么这个部分内地址的计算都以此为基准。
在汇编器的帮助下，除了ROM等一些不变的地址外，程序中不需要再硬编码内存地址。
3. 为了更有效地利用硬件资源，提高CPU的利用率，在操作系统的控制下，可以同时运行多个程序。每个程序仍以单程序同样的方式存储和访问内存，内存访问硬编码导致程序之间互相读写内存，需要修改代码避免。
4. Intel 8086以来，CPU使用分段模型，即用“段基址+段内偏移地址”的方式访问内存。程序中根据相对段基址的偏移位置访问内存，操作系统装载程序时为程序分配空闲内存，再将段基址寄存器中的地址改成分配的地址。
每个程序应以可执行文件的格式（coff、elf、pe等）存储，并指定入口，由操作系统装载运行，运行结束后返回操作系统。
但是分段模型仅是提出了规范，并没有从机制上将程序使用的内存空间相互隔离。
