开放式系统互联模型（Open System Interconnection Model，OSI）是一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。该模型将通信系统中的数据流划分为七个层，从跨通信介质传输位的物理实现到分布式应用程序数据的最高层表示。每个中间层为其上一层提供功能，其自身功能则由其下一层提供。功能的类别通过标准的通信协议在软件中实现。

|   | 调用该层服务需要传入 |将数据包封装成  | 一次服务调用下层服务次数| 传送数据到 | 主要使用 |
| ------------------------------------------------------------ | ----------------------------------- | ------------ | ------------ | ------------ | ------------ |
| 物理层（Physical Layer） | 待传数据 | 比特流（bitstream） |       | 所有与发送方存在通路的地方 | 网线、集线器 |
| 数据链路层（Data Link Layer） | 待传数据、目标物理地址 | 帧（frame） | N  | 网络节点 | 交换机、桥接器 |
| 网络层（Network Layer） | 待传数据、目标网络地址 | 数据包/分组（packet） | N | 网络适配器 | 网络适配器、路由器 |
| 传输层（Transport Layer） | 待传数据、目标网络地址+端口号 | 报文段（segment） | 1 | 套接字 | 操作系统进程 |
| 会话层（Session Layer） | 待传数据、会话ID |  | 1 | 会话实体                          |              |
| 表示层（Presentation Layer） | 待传原始信息（未编码、加密、压缩） | 报文（message） | 1  |                            |              |
| 应用层（Application layer） | 请求消息（包含请求方法、资源的标识符及使用的协议） | 报文内容 | 1 | 应用程序                       |              |

### 1. 数据链路层

交换机中有一张转发表，该转发表记录了所有MAC地址的位置，这样就可以进行包的转发了。可是这张转发表中要保存有所有MAC地址的方向，这张转发表就会很大，转发速度会变慢（因为查询变慢）。而且所有的交换机都要有全Internet的地址，都要有足够的性能来存下全网地址。估计建造这样的Internet成本是现在的几万倍，甚至更高。

所以交换机只负责小范围的路由转发。扁平没有层次、与设备绑定的MAC地址，类似于一个人的身份证号，可以作为标识一台设备的代号，但无法很好的用于路由寻址功能。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210814145238724.png" alt="image-20210814145238724" style="zoom:80%;" />

### 2. 网络层

![img](file://F:\notebook\网络\网络层.assets\2.png)

一台路由器的每个端口都有自己的MAC地址，都会被分配不同的IP地址。

如果每台主机/路由器的IP地址都是任意分配的，也会造成巨大转发表的问题。需要把IP地址前缀相同的主机直接相连，通过聚合路由的方式减小转发表。

CIDR（Classless Inter-Domain Routing，无类别域间路由）是把几个小网络聚合成一个大网络来做表示，而VLSM（Variable Length Subnet Mask，可变长子网掩码）则是把一个大网络继续细分为几个小网络进行IP地址分配。CIDR能让路由器的路由条目得到有效的减少，从而减少路由通告，降低路由器负担，而VLSM则是充分利用IP进行地址分配来解决IP地址不被浪费的问题，节约IP地址空间，更为有效的使用。

#### 保留的特殊IP地址

- 网络地址：主机部分全为0

- 直接广播地址：主机部分全为1

- 限制广播地址：255.255.255.255

- 本地机器上的所有IPv4地址：0.0.0.0

- 环回（loopback）地址：127.0.0.0 ~ 127.255.255.255

- 本机（localhost）地址：127.0.0.1

- 组播地址：224.0.0.0 ~ 239.255.255.255

- 实验地址：240.0.0.0 ~ 255.255.255.254

- DHCP失败地址：169.254.0.0 ~ 169.254.255.255

- 运营商级路由（Carrier-grade NAT）：100.64.0.0 ~ 100.127.255.255

- 私有地址：10.0.0.0 ~ 10.255.255.255  172.16.0.0  ~  172.31.255.255  192.168.0.0 ~ 192.168.255.255

#### 网关（Gateway）

网关实质上是一个网络通向其他网络的IP地址。比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1~192. 168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1~192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）与主机的IP 地址作 “与” 运算的结果不同判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。
一台路由器可以连接多个网络，每个端口的IP地址即是对应网络的网关。如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以连接多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。默认网关一般填写192.168.x.1。

#### 路由表（Routing Table）

![IP地址和子网划分学习笔记之《IP地址详解》](file://F:\notebook\网络\IP地址.assets\9.png)

| Network destination |     Netmask     |    Gateway    |   Interface   | Metric |
| :-----------------: | :-------------: | :-----------: | :-----------: | :----: |
|       0.0.0.0       |     0.0.0.0     |  192.168.0.1  | 192.168.0.100 |   10   |
|      127.0.0.0      |    255.0.0.0    |   127.0.0.1   |   127.0.0.1   |   1    |
|     192.168.0.0     |  255.255.255.0  | 192.168.0.100 | 192.168.0.100 |   10   |
|    192.168.0.100    | 255.255.255.255 |   127.0.0.1   |   127.0.0.1   |   10   |
|     192.168.0.1     | 255.255.255.255 | 192.168.0.100 | 192.168.0.100 |   10   |

#### traceroute

```
traceroute 8.8.8.8
```
- 192.168.0.2（本机IP）
- 192.168.0.1（路由器LAN口IP）出关，192.168.1.2（路由器WAN口IP）入关
- 192.168.1.1（光纤接入LAN IP）出关，100.70.221.25（光纤接入WAN IP，运营商级NAT IP地址）入关
- 100.70.128.1（运营商级NAT IP地址）出关，58.212.133.75（江苏省南京市雨花台区 电信）入关   **<= 网络查询本机IP显示的结果**
- 58.217.231.129（ 江苏省南京市玄武区 电信）出关
- 218.2.121.141（ 江苏省南京市 电信）出关
- 202.97.101.33（ 香港 中国电信骨干网接入点）出关
- 202.97.83.1（中国 电信骨干网）出关
- 202.97.85.34（中国 电信骨干网）出关
- 202.97.25.226（中国 电信骨干网）出关
- 202.97.62.214（中国 电信骨干网）出关
- 108.170.241.1（香港 特别行政区）出关
- 74.125.253.93（美国 Google全球边缘网络）出关
- 8.8.8.8（美国 加利福尼亚州圣克拉拉县山景市谷歌公司DNS服务器）

![1](file://F:\notebook\网络\网络层.assets\3.png)

#### NAT

网络地址转换（Network Address Translation，NAT）在计算机网络中是一种在IP数据包通过路由器或防火墙时重写来源IP地址或目的IP地址的技术。这种技术被普遍使用在有多台主机但只通过一个公有IP地址访问互联网的私有网络中。它是一个方便且得到了广泛应用的技术。当然，NAT也让主机之间的通信变得复杂，导致了通信效率的降低。

![IP地址和子网划分学习笔记之《IP地址详解》](file://F:\notebook\网络\IP地址.assets\4.png)

经过多层NAT，主机连接到一个有外网IP的路由器接口。该外网IP即是网络查询本机IP显示的结果。

#### 内网穿透

在计算机科学中，NAT穿越（NAT traversal）涉及TCP/IP网络中的一个常见问题，即在处于使用了NAT设备的私有TCP/IP网络中的主机之间创建连接的问题。

尽管有许多穿越NAT的技术，但没有一项是完美的，这是因为NAT的行为是非标准化的。这些技术中的大多数都要求有一个公共服务器，而且这个服务器使用的是一个众所周知的、从全球任何地方都能访问得到的IP地址。一些方法仅在创建连接时需要使用这个服务器，而其它的方法则通过这个服务器中继所有的数据——这就引入了带宽开销的问题。

两种常用的NAT穿越技术是：UDP路由验证和STUN。除此之外，还有TURN、ICE、ALG，以及SBC。

#### 代理Proxy

代理（英语：Proxy）也称网络代理，是一种特殊的网络服务，允许一个终端（一般为客户端）通过这个服务与另一个终端（一般为服务器）进行非直接的连接。一些网关、路由器等网络设备具备网络代理功能。一般认为代理服务有利于保障网络终端的隐私或安全，在一定程度上能够阻止网络攻击。

提供代理服务的电脑系统或其它类型的网络终端称为代理服务器（英文：Proxy Server）。一个完整的代理请求过程为：客户端首先与代理服务器创建连接，接着根据代理服务器所使用的代理协议，请求对目标服务器创建连接、或者获得目标服务器的指定资源（如：文件）。在后一种情况中，代理服务器可能对目标服务器的资源下载至本地缓存，如果客户端所要获取的资源在代理服务器的缓存之中，则代理服务器并不会向目标服务器发送请求，而是直接传回已缓存的资源。一些代理协议允许代理服务器改变客户端的原始请求、目标服务器的原始响应，以满足代理协议的需要。代理服务器的选项和设置在计算机程序中，通常包括一个“防火墙”，允许用户输入代理地址，它会遮盖他们的网络活动，可以允许绕过互联网过滤实现网络访问。

代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求URI，并不会直接发送给前方持有资源的目标服务器。

持有资源实体的服务器被称为源服务器。从源服务器返回的响应经过代理服务器后再传给客户端。

#### 虚拟网卡

虚拟网卡主要是建立远程计算机间的局域网。虚拟网卡链接技术就是VPN。比如说你可以和别的地方的几台机子，通过建立虚拟HUB 实现VPN client的链接，这样就算是在这几台远程计算机间建立的局域网，也能和你的机子一起实现局域网的功能。最普通的就是局域网互联游戏。在这方面比较常用的软件有openVPN ,packetix VPN ,hamachi， 其中，hamachi是运用最简单的VPN软件。

#### 虚拟局域网VLAN

虚拟局域网（Virtual Local Area Network或简写VLAN, V-LAN）是一种建构于局域网交换技术（LAN Switch）的网络管理的技术，网管人员可以借此透过控制交换机有效分派出入局域网的分组到正确的出入端口，达到对不同实体局域网中的设备进行逻辑分群（Grouping）管理，并降低局域网内大量资料流通时，因无用分组过多导致壅塞的问题，以及提升局域网的信息安全保障。

#### 虚拟专用网络VPN

在公用网络上建立专用网络，进行加密通讯。vpn通常拿来做2个事情，一个是可以让世界上任意2台机器进入一个虚拟的局域网中（当然这个局域网的数据通讯是加密的，很安全，用起来和一个家庭局域网没有区别），一个是可以用来翻墙。

vpn通过操作系统的接口直接虚拟出一张网卡，后续整个操作系统的网络通讯都将通过这张虚拟的网卡进行收发。这和任何一个代理的实现思路都差不多，应用层并不知道网卡是虚拟的，这样vpn虚拟网卡将以中间人的身份对数据进行加工，从而实现各种神奇的效果。具体来说，vpn是通过编写一套网卡驱动并注册到操作系统实现的虚拟网卡，这样数据只要经过网卡收发就可以进行拦截处理。

### 3. 传输层

TCP/IP 中有两个具有代表性的传输层协议，分别是 TCP 和 UDP。

#### TCP

|             | 服务器                                                | 客户端                                                |
| ----------- | ----------------------------------------------------- | ----------------------------------------------------- |
| 导入依赖    | import socket                                         | import socket                                         |
| 创建套接字  | s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) | s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) |
| 设置监听    | s.bind(('127.0.0.1', 9999))                           |                                                       |
| 开始监听    | s.listen(5)                                           |                                                       |
| 建立连接    | _s, addr = s.accept()                                 | s.connect(('127.0.0.1', 9999))                        |
| 传输数据1   | data = _s.recv(1024).decode('UTF8')                   | s.send('一二三'.encode('UTF8'))                       |
| 传输数据2   | _s.send('123'.encode('UTF8'))                         | data = s.recv(1024).decode('UTF8')                    |
| 关闭套接字1 | _s.close()                                            | s.close()                                             |
| 关闭套接字2 | s.close()                                             |                                                       |
#### UDP

|            | 服务器                                               | 客户端                                                 |
| ---------- | ---------------------------------------------------- | ------------------------------------------------------ |
| 导入依赖   | import socket                                        | import socket                                          |
| 创建套接字 | s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM) | s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)   |
| 设置监听   | s.bind(('127.0.0.1', 9999))                          |                                                        |
| 传输数据1  | _data, addr = s.recvfrom(1024).decode('UTF8')        | s.sendto('一二三'.encode('UTF8'), ('127.0.0.1', 9999)) |
|            | data = _data.decode('UTF8')                          |                                                        |
| 传输数据2  | s.sendto('123'.encode('UTF8'), addr)                 | data = s.recv(1024).decode('UTF8')                     |
| 关闭套接字 | s.close()                                            | s.close()                                              |

#### TCP与UDP的区别

- 基于连接与无连接；
- 对系统资源的要求（TCP较多，UDP少）；
- UDP程序结构较简单；
- 流模式与数据报模式 ；
- TCP保证数据正确性，UDP可能丢包；
- TCP保证数据顺序，UDP不保证；