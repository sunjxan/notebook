协同过滤算法是指仅仅基于用户行为数据设计的推荐算法。

#### 基于邻域的方法

“和你买了相同物品的人也会买”

- 基于用户的协同过滤userCF（最古老，1992）  社会化
1. 找到和目标用户兴趣相似的用户集合 => 用户相似性表

   根据用户行为计算任意两个用户之间的相似度

   **找出与某用户相似度最大的K个用户**

2. 找到这个集合中的用户喜欢的，且目标用户没有听说过的物品推荐给目标用户

   找出这K个用户喜欢的，且目标用户没有听说过的物品

   根据用户相似度和用户行为计算目标用户对这些物品的感兴趣程度（以平均值为基准）

   取前N个最感兴趣的物品
- 基于物品的协同过滤itemCF（应用最多，亚马逊提出）  个性化
1. 计算物品之间相似度 => 物品相关度表

   根据对物品感兴趣的用户计算任意两个物品之间的相似度

2. 根据物品的相似度和用户的历史行为给用户生成推荐列表

   **找出目标用户喜欢的物品最相似的K个物品组成的集合**

   根据物品相似度和用户行为计算目标用户对这些物品的感兴趣程度

   取前N个最感兴趣的物品

- 相似度权重计算
1. 倒排表

2. Jaccard公式
$$
\operatorname{Jaccard}(X, Y)=\frac{|X \cap Y|}{|X \cup Y|}
$$

3. 余弦相似度Cosine Similarity

$$
\cos (x 1, x 2)=\frac{\sum_{k=1}^{n} x_{1 k} x_{2 k}}{\sqrt{\sum_{k=1}^{n} x_{1 k}^{2}} \sqrt{\sum_{k=1}^{n} x_{2 k}^{2}}}
$$

4. 调整余弦相似度Adjusted Cosine Similarity
$$
\operatorname{sim}(x 1, x 2)=\frac{\sum_{k=1}^{n}\left(x_{1 k}-\overline{x_{k}}\right)\left(x_{2 k}-\overline{x_{k}}\right)}{\sqrt{\sum_{k=1}^{n}\left(x_{1 k}-\overline{x_{k}}\right)^{2}} \sqrt{\sum_{k=1}^{n}\left(x_{2 k}-\overline{x_{k}}\right)^{2}}}
$$

5. Pearson相关系数
$$
\operatorname{sim}(x, y)=\frac{\sum_{k=1}^{n}\left(x_{k}-\bar{x}\right)\left(y_{k}-\bar{y}\right)}{\sqrt{\sum_{k=1}^{n}\left(x_{k}-\bar{x}\right)^{2}} \sqrt{\sum_{k=1}^{n}\left(y_{k}-\overline{y}\right)^{2}}}
$$

#### 隐语义模型LFM(Latent Factor Model)

矩阵因子分解

$$
R_{U*I}=P_{U*K}Q_{K*I}
$$
学习到模型后，计算用户对所有物品的兴趣权重，然后排名，返回权重最大的N个物品
生成一个用户推荐列表时的速度太慢，不能在线实时计算

#### 基于图的模型

用户物品二分图G(V, E)

随机游走PersonalRank算法