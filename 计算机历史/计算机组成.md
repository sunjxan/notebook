#### 开关

手动控制
可以使电路开路、使电流中断或使其流到其他电路的电子元件。

![1](计算机组成.assets\1.png)

#### 继电器

自动控制
继电器只不过是一个连接在普通开关上的电磁铁而已。通过使用电流来打开和关闭电磁铁，你可以打开和关闭开关。

<img src="https://s3-eu-west-1.amazonaws.com/rpf-futurelearn/how-computers-work/week_1/1.12-Relay.gif" alt="img" style="zoom:67%;" />

通过自动控制的开关，在电路上传的的不仅是电流，还可以传递电路通断的状态。

#### 真空管

1. 灯丝加热阴极，阴极受热后会发射出一些电子。当我们在灯丝和阳极之间制造一个电场时，这个电场就会加速或减速灯丝射出的电子——宏观上，就是加反向电压时，电子都被电场“送”回了灯丝，于是灯丝和阳极之间不存在电流，相当于断路状态；而加正向电压时，电子被电场加速，可以更顺利的到达阳极。这就是“真空二极管”。

<img src="https://pic1.zhimg.com/80/v2-666a0a9bb36f83af65c054ac128f6d24_720w.jpg" alt="img" style="zoom:50%;" /><img src="https://pic3.zhimg.com/80/v2-95d7da3bd20af8b8a4c76493b8cc2fee_720w.jpg" alt="img" style="zoom:50%;" />

2. 在真空二极管的基础上，我们在“灯丝”和“阳极”之间增加一个金属网，然后在灯丝和金属网之间加一个电压。那么，当这个电压建立的电场削弱电子动能时，阳极就接受不到电流；而这个电场加速电子时，就会有更多电子到达阳极。因为灯丝和金属网距离更近，同样的电压产生的电场强度更高；因此两者之间很小的电压变化都能很大幅度的影响阳极电流。这就是真空三极管“截止”和“放大”的原理。

<img src="https://pic2.zhimg.com/80/v2-45535aa5f5dd68cdc46ef6b7e23e9f2d_720w.jpg" alt="img" style="zoom:50%;" />

#### 晶体管
1. 在硅晶体中掺入杂质硼元素，硅原子的自由电子被硼原子吸收，原有位置称为空穴，进一步吸收邻接硅原子中的电子。通过重复这个过程， 空穴不断移动，从而形成电流。由空穴作为载流子的半导体称为“P(ositive)型半导体”。

![img](https://www.renesas.com/sites/default/files/inline-images/semiconductor-ptype-zh.jpg)

2. 在硅晶体中掺入杂质磷元素，磷原子的自由电子将硅原子的电子赶出，取代它的位置，而原有电子变为自由电子，再将邻接硅原子中的电子赶出。通过重复这个过程，自由电子不断移动，从而形成电流。由电子作为载流子的半导体称为“N(egative)型半导体”。

![img](https://www.renesas.com/sites/default/files/inline-images/semiconductor-ntype-zh.jpg)

3. 把一块P型和一块N型半导体结合起来，两者的交界面就会出现相互作用。P型和N型结界面周围，各个载流子扩散并结合，从而出现了不存在载流子的区域。在这个区域里，带电的杂质形成势垒电场，通过阻止载流子扩散阻碍结合。我们将这个不存在载流子的势垒电场称为耗尽层，或PN结。其中，耗尽层靠N型一侧带正电（电子被另一侧的空穴夺去了），靠P型一侧带负电（夺取了多余的电子）。

![img](https://www.renesas.com/sites/default/files/inline-images/diode-structure-zh.jpg)

4. 从PN结的形成原理可以看出，要想让PN结导通形成电流，必须消除其空间电荷区的内部电场的阻力。很显然，给它加一个反方向的更大的电场，即P区接外加电源的正极，N区接负极，就可以抵消其内部自建电场，使载流子可以继续运动，从而形成线性的正向电流。而外加反向电压则相当于内建电场的阻力更大，PN结不能导通，仅有极微弱的反向电流。上述电流单向流动即为二极管的基本原理—整流作用。

![image-20210803013730199](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210803013730199.png)

5. 三极管顾名思义具有三个电极。二极管是由一个PN结构成的，而三极管由两个PN结构成，共用的一个电极成为三极管的基极(Base)，其他的两个电极分别称为集电极(Collector)和发射极(Emitter)。基区和发射区之间的结成为发射结，基区和集电区之间的结成为集电结。其中基极是控制极，另外两个端点之间的伏安特性关系是受到控制极的非线性电阻关系。晶体管基于输入的电流或电压，改变输出端的阻抗，从而控制通过输出端的电流，因此晶体管可以作为电流开关。而因为晶体管输出信号的功率可以大于输入信号的功率，因此晶体管可以作为电子放大器。

![图5 NPN晶体管概要图](https://www2.renesas.cn/sites/default/files/inline-images/transistor-overview-zh.jpg)

6. 双极结型晶体管 （Bipolar Junction Transistor，BJT）

![bipolar junction transistor tutorial](https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/transistor-tran61.gif)

NPN型BJT开关

![transistor switch in cut-off](https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/transistor-tran46.gif)

![transistor switch in saturation](https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/transistor-tran47.gif)

7. 晶体管－晶体管逻辑（英语：Transistor-Transistor Logic，缩写为TTL），是应用广泛的一种逻辑门数字电路，由BJT组成。

与TTL分庭抗礼的是CMOS，旧时两者相比较TTL主要是速度快，CMOS则是速度慢，但省电、成本比TTL低。随着CMOS技术的进步，其反应速度已经超越TTL。而且CMOS内部不具有制作麻烦的电阻，所以TTL可说几乎没有发展。目前TTL主要应用于教育或是较简单的数字电路。

8. 结型场效应晶体管（Junction Field Effect Transistor，JFET）

![junction field effect transistor symbol](https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/transistor-tran17.gif)

9. 金属氧化物半导体场效应晶体管（Metal Oxide Semiconductor Field Effect Transistor，MOSFET）

![mosfet symbol](https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/transistor-tran20a.gif)

增强（Enhancement ）模式NMOS开关

![mosfet switch cut-off](https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/transistor-tran57.gif)

![mostfet switch saturation](https://www.electronics-tutorials.ws/wp-content/uploads/2018/05/transistor-tran58.gif)

10. NMOS（N-type）、PMOS（P-type）和CMOS（互补式）

![NMOS Transistor](http://electrotopic.com/wp-content/uploads/2019/11/NMOS-Transistor.jpg)

![PMOS Transistor](http://electrotopic.com/wp-content/uploads/2019/11/PMOS-Transistor.jpg)

CMOS（Complementary MOS）是一种互补型连接的MOSFET。采用此种电路结构时，无论是IN电压为0V，还是VCC的情况，只有一方的MOSFET为ON。因此从VCC到GND基本上无电流通过，可用于构成功耗极低的理想电路。CMOS具有只有在晶体管需要切换启动与关闭时才需消耗能量的优点，因此非常节省电力且发热量少，且工艺上也是最基础而最常用的半导体器件。

![图8 CMOS构成的变频器](https://www2.renesas.cn/sites/default/files/inline-images/cmos-inverter-en.jpg)

#### 集成电路

经过集成电路（Integrated Circuit，IC）和微处理器（Microprocessor**，**µP或uP）的发展，现代CPU已经是非常复杂的设备，芯片上嵌入了数十亿个微小的晶体管。虽然这对完成工作很有帮助，但它使人很难理解CPU的实际工作方式和它在做什么。但是，这几十亿个晶体管中的每一个都只是一个开关，所以可以用任何一种电子开关--比如说继电器--来构建一个CPU。

计算机中的很多事情，底层其实都很简单，让人难以理解的，是一层层精妙的抽象。

#### 逻辑门

逻辑门是在集成电路上的基本组件。简单的逻辑门可由晶体管组成。这些晶体管的组合可以使代表两种信号的高低电平在通过它们之后产生高电平或者低电平的信号。高、低电平可以分别代表逻辑上的“真”与“假”或二进制当中的1和0，从而实现逻辑运算。

![image-20210803214620867](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210803214620867.png)

![image-20210803215921113](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210803215921113.png)

1. 与门

<img src="D:\Desktop\Relay_and.svg.png" alt="Relay_and.svg" style="zoom: 33%;" /><img src="D:\Desktop\1280px-Cmos_and.svg.png" alt="1280px-Cmos_and.svg" style="zoom:33%;" />

2. 或门

<img src="D:\Desktop\Relay_or.svg.png" alt="Relay_or.svg" style="zoom:33%;" /><img src="D:\Desktop\1280px-Cmos_or.svg.png" alt="1280px-Cmos_or.svg" style="zoom:33%;" />

3. 非门

<img src="D:\Desktop\Not.png" alt="Not" style="zoom:200%;" /><img src="D:\Desktop\1024px-CMOS_Inverter.svg.png" alt="1024px-CMOS_Inverter.svg" style="zoom:33%;" />

4. 与非门

<img src="D:\Desktop\Relay_nand.svg.png" alt="Relay_nand.svg" style="zoom:33%;" /><img src="D:\Desktop\1024px-Cmos_nand.svg.png" alt="1024px-Cmos_nand.svg" style="zoom: 50%;" />

5. 或非门

<img src="D:\Desktop\Relay_nor.svg.png" alt="Relay_nor.svg" style="zoom:33%;" /><img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210810135454847.png" alt="image-20210810135454847" style="zoom:150%;" />

6. 异或门

<img src="D:\Desktop\1280px-Relay_xor.svg.png" alt="1280px-Relay_xor.svg" style="zoom:33%;" /><img src="D:\Desktop\1024px-Cmos_xor.svg.png" alt="1024px-Cmos_xor.svg" style="zoom: 50%;" />

#### 加法器

1. 半加器

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210803221721363.png" alt="image-20210803221721363" style="zoom: 50%;" /><img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210803221415938.png" alt="image-20210803221415938" style="zoom: 50%;" />  

2. 全加器

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210803221612898.png" alt="image-20210803221612898" style="zoom:50%;" />

3. 8位加法器

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210803222119502.png" alt="image-20210803222119502" style="zoom: 67%;" />


#### 传输门和总线

在逻辑电路里，大家共用的公共线路称为总线。

使用一只开关来控制多条线路的通断，称为传输门。通过传输门使多个输入输出数据轮流使用总线，保证不会发生冲突。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805160228122.png" alt="image-20210805160228122" style="zoom: 50%;" />

#### 算术逻辑单元

算术逻辑单元（Arithmetic logic unit，ALU）是一种可对二进制整数执行算术运算或位运算的组合逻辑数字电路。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210803222701182.png" alt="image-20210803222701182" style="zoom: 67%;" />

#### 组合逻辑电路

1. 编码器
根据输入值，输出一个编码。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804153211799.png" alt="image-20210804153211799" style="zoom:67%;" />![image-20210804153505362](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804153505362.png)

2. 译码器/解码器
根据选择线的值，输出中的一个将被激活。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804150243786.png" alt="image-20210804150243786" style="zoom:50%;" />![image-20210804153539846](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804153539846.png)

3. 数据选择器（Data Selector）/多路复用器（Multiplexer，MUX）
根据选择线的值，数据输入中的一个将被连接到输出。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804153417407.png" alt="image-20210804153417407" style="zoom: 67%;" /><img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804153937178.png" alt="image-20210804153937178" style="zoom: 67%;" /><img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804154014663.png" alt="image-20210804154014663" style="zoom: 67%;" />

4. 数据分发器（Data distributor）/解多路复用器（De-Multiplexer，DEMUX）
根据选择线的值，数据输入将被连接到输出中的一个。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804154449994.png" alt="image-20210804154449994" style="zoom:67%;" /><img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804154251620.png" alt="image-20210804154251620" style="zoom:67%;" /><img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804154315455.png" alt="image-20210804154315455" style="zoom: 67%;" />

#### 时序逻辑电路

1. 带反馈的NOT门，值周期性改变，称为振荡器，输出时钟脉冲信号

![img](https://pic3.zhimg.com/80/v2-8213ae4eab4ebc6baf4c8f049a3970ba_720w.jpg)

![时钟信号](http://www.vue5.com/upload/digital_circuits/images/clock_signal.jpg)

2. 带反馈的OR门，输入0值不变，输入1值为1

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804020305764.png" alt="image-20210804020305764" style="zoom:50%;" />

3. 带反馈的AND门，输入1值不变，输入0值为0

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804020612224.png" alt="image-20210804020612224" style="zoom:50%;" />

#### 锁存器

1. SR锁存器
   SET=1置1，RESET=1置0，都=0不变，不允许都=1

![img](https://upload.wikimedia.org/wikipedia/commons/thumb/c/c6/R-S_mk2.gif/220px-R-S_mk2.gif)

2. AND-OR锁存器

SET=0时，相当于带反馈的AND门，输入为RESET的非
RESET=0时，相当于带反馈的OR门，输入为SET
SET=RESET=0时，相当于电阻，值不变

SET=1置1，RESET=1置0，都=0不变，都=1置0

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804021131883.png" alt="image-20210804021131883" style="zoom: 67%;" />

3. 门控D锁存器

配置SET与RESET互反，并添加门控输入G，G=0时输出不变

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804023316337.png" alt="image-20210804023316337" style="zoom: 67%;" />

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804023345495.png" alt="image-20210804023345495" style="zoom: 50%;" />

#### 触发器
CP（时钟脉冲，ClockPulse）作为门控输入

1. SR触发器：SET=1置1，RESET=1置0，都=0不变，不允许都=1

<img src="http://www.vue5.com/upload/digital_circuits/images/sr_flipflop.jpg" alt="SR触发器" style="zoom: 67%;" />

2. D触发器：D=0置0，D=1置1

<img src="http://www.vue5.com/upload/digital_circuits/images/d_flipflop.jpg" alt="D触发器" style="zoom:67%;" />

3. JK触发器：J=1置1，K=1置0，都=0不变，都=1反转

<img src="http://www.vue5.com/upload/digital_circuits/images/jk_flipflop.jpg" alt="JK触发器" style="zoom:67%;" />

4. T触发器：T=0不变，T=1反转

<img src="http://www.vue5.com/upload/digital_circuits/images/t_flipflop.jpg" alt="T触发器" style="zoom:67%;" />

5. 主从触发器（边沿触发器）：需要一正一反两个控制输入，才会保存输入值

![image-20210804121042037](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804121042037.png)

控制端旁有一个三角形，表示边沿触发

<img src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8c/D-Type_Flip-flop.svg/220px-D-Type_Flip-flop.svg.png" alt="img" style="zoom:67%;" />

6. 乒乓触发器

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804235822644.png" alt="image-20210804235822644" style="zoom: 50%;" /><img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805000022004.png" alt="image-20210805000022004" style="zoom: 50%;" />

#### 寄存器

一个触发器可以保存一个比特。一个寄存器通常由好多个边沿D触发器组成。如下图这个寄存器包含了5个上升沿D触发器，能用来保存一个5比特长的二进制数。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804235044812.png" alt="image-20210804235044812" style="zoom:80%;" /><img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804235216035.png" alt="image-20210804235216035" style="zoom:50%;" />

#### 循环移位寄存器

将多个上升沿D触发器首尾相连，如下图所示，随着时钟脉冲信号，比特“1”会在触发器间顺序地传递，从左向右，最后再回到左边，这样循环往复。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805002818930.png" alt="image-20210805002818930" style="zoom:50%;" />

#### 计数器

将多个上升沿乒乓触发器首尾相连，构成一个计数器。它可以计数时钟脉冲的个数。如下图这个计数器包含了5个上升沿乒乓触发器，最大计数值为31。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805000213045.png" alt="image-20210805000213045" style="zoom: 50%;" />

#### 存储器（SRAM）

具有唯一输入/输出线的存储器，它可以保存或者读出一个比特（G是传输门）

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805110339958.png" alt="image-20210805110339958" style="zoom:50%;" />

写入一个比特的原理

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805110420594.png" alt="image-20210805110420594" style="zoom:50%;" />

读出一个比特的原理

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805110512639.png" alt="image-20210805110512639" style="zoom:50%;" />

一个比特单元

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805111048635.png" alt="image-20210805111048635" style="zoom: 67%;" />

可以读/写单个5位二进制数的存储器

![image-20210805110639637](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805110639637.png)

可以保存4个二进制数、每个数包含5个比特的存储器

![image-20210805110719632](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805110719632.png)

使用译码器简化存储器设计

![image-20210805110853287](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805110853287.png)

封装后的存储器，它有4个地址线A0～A3，可以访问0000～1111这16个存储单元，这就是它的存储容量。它有D0～D4五根数据线，这意味着它每次可以写入或者读出一个5比特的二进制数。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805110943948.png" alt="image-20210805110943948" style="zoom: 50%;" />

通过级联的方式扩大存储器的容量

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210804024312094.png" alt="image-20210804024312094" style="zoom:67%;" />

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805102603574.png" alt="image-20210805102603574" style="zoom: 80%;" />

抽象出最终的存储器

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805102742187.png" alt="image-20210805102742187" style="zoom: 80%;" />

#### 控制器

下图是一个完整的加法运算电路，通过操作传输门开关GA、GB，控制数据流动，完成“装载数据到寄存器RA”、“数据相加”、“保存结果到寄存器TR”等动作。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805163031015.png" alt="image-20210805163031015" style="zoom:50%;" />

通过设计逻辑电路，将装载和相加两个动作分别配置到一个开关控制，使用循环移位寄存器RR产生脉冲控制传输门，得到一个简单的控制器，控制整个加法运算。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805225629914.png" alt="image-20210805225629914" style="zoom: 80%;" />

之前参与相加的数都是用开关得到的。现在将存储器和加法器合在一起，实现从存储器里不断取数、然后相加的功能。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805230446298.png" alt="image-20210805230446298"  />

根据存储程序原理，将操作开关的指令序列转换为数字形式的操作码，放在存储器里，每次执行前取出。操作码被取出，地址计数器AC自动加1。

![image-20210805233453964](C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805233453964.png)

使用振荡器替换手动开关，驱动整个电路不断完成取指令和执行指令的动作，得出新的控制器。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805235151105.png" alt="image-20210805235151105" style="zoom: 80%;" />

#### 时钟与同步

从计算机时代诞生以来，芯片的最基本的工作方式就是利用时钟来组织和运行其任务。同步电路是由时钟驱动存储元件的电路，也就是说存储元件的状态只在时钟沿到来的时候才能发生变化。组合逻辑不需要任何时序或控制，只要输入变化了，值就通过逻辑门网络传播。因为组合逻辑电路在输入变化时输出可能出现毛刺(glitch)，而存储元件因为只会在时钟沿到来时才会更新状态，那么在时钟沿之间的时间状态是稳定的，这样的同步电路可以消除组合电路中的毛刺。同步电路的好处是时序很清晰，电路中的存储元件例如触发器都是依照一个固定的节拍来工作，便于EDA工具来进行延时的分析和计算，所以同步电路几乎占据了当前数字芯片的绝大多数部分。

设计芯片时的首要考虑是在下一次时钟周期来临前尽量将事情做好。当微处理器执行一项给定的操作时，电子信号在极细的金属线上传输、交叉、遇到逻辑门，直到最终将计算结果存放到临时的存储器（我们称之为寄存器）中。比如，你想做4乘以6的乘法。如果能在计算正在进行时，将芯片的速度降下来，看一看寄存器，你就会看到寄存器里的数值在最终得出正确答案之前会改变很多次，比如，从4到12再到8。这是因为发出的用于执行该运算的信号要经过许多不同的数据通道才能到达寄存器，而只有在所有的信号都送达寄存器之后才会给出正确的响应。时钟的作用就是保证在给定的时间内得到响应。芯片的设计要保证通过电路的最慢的通道，也就是线路最长和门最多的通道，能在单个的时钟周期内到达寄存器。整个电路的速度将受限于最慢的模块，时钟周期必须大于最慢模块的整体计算时间，这就给其它模块带来了延迟。

<img src="https://img-blog.csdnimg.cn/20200804190825619.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzc4MTIyOQ==,size_16,color_FFFFFF,t_70" alt="img" style="zoom:80%;" />

![img](https://img2018.cnblogs.com/i-beta/1858706/201912/1858706-20191222223900384-1509868781.png)

通过使用一个中央时钟来进行芯片上工作的管理，工程师们不再需要担心各种长度不等的成百万的小的金属线；各种信号只要在下一个时钟周期之前被送达寄存器，它们可以以任何顺序被送达。在这样的统一的时钟原则下，成百个工程师的团队就可以协调他们的工作。

我们在试图理解处理器的动作时，不要将关注点放在逻辑电路上，而要将关注点放在寄存器值的变化上。因为组合逻辑电路不受时钟信号影响，仅负责信号的传播，真正依赖时钟信号的是寄存器的写入行为。我们的目标便是寄存器的值随着时钟周期发生正确的变化。


#### 状态机

如果时序电路的所有开关状态只在时钟脉冲信号边沿处改变，则该时序电路被称为**同步时序电路**。这意味着，同步时序电路的所有输出同时改变。因此，同步时序电路的输出与时钟脉冲信号的上升沿或下降沿同步。时钟脉冲信号的意义在于，每个周期都向整个电路发出一个同步信号，让整个电路协同地工作。

如果将电路的所有触发器的存储值作为一个状态，因为触发器数量是有限的，可以将同步时序电路看作一个有限状态机。它的下一个状态不仅仅依赖于当前状态，还依赖于当前的输入（也就是整体电路的输入端口）。时钟就是我们控制状态机更新状态的手段。在某个电路已经稳定的状态下，组合逻辑电路从当前各个触发器的输出运算得到每一个触发器下第一个状态应该是什么值。将这些信号连接到各个触发器的输入端，在每个时钟有效跳变沿，电路中所有的触发器同时更新状态，整个状态机同步地过渡到下一个状态。

有限状态机（Finite-State Machine，FSM），又称有限状态自动机（Finite-State Automation，FSA），简称状态机，是表示有限个状态以及在这些状态之间的转移和动作等行为的数学计算模型。

米利型有限状态机（Mealy machine）是基于它的当前状态和输入生成输出的有限状态自动机。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805010340413.png" alt="image-20210805010340413" style="zoom: 67%;" />

摩尔型有限状态机（Moore machine）是指输出只由当前的状态所确定的有限状态自动机。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210805010505319.png" alt="image-20210805010505319" style="zoom:67%;" />

每个Mealy机都有一个等价的Moore机。

#### CPU

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210806004248875.png" alt="image-20210806004248875" style="zoom: 67%;" />

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210806004416997.png" alt="image-20210806004416997" style="zoom: 67%;" />

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210806005217472.png" alt="image-20210806005217472" style="zoom:67%;" />

1. 指令集架构

复杂指令集计算机（Complex Instruction Set Computer，CISC）是一种微处理器指令集架构，每个指令可执行若干低端操作，诸如从存储器读取、存储和计算操作，全部集于单一指令之中。复杂指令集的特点是指令数目多而复杂，每条指令字长并不相等，电脑必须加以判读，并为此付出了性能的代价。

精简指令集计算机（reduced instruction set computer，RISC），是计算机中央处理器的一种设计模式。这种设计思路可以想像成是一家模块化的组装工厂，对指令数目和寻址方式都做了精简，使其实现更容易，指令并行执行程度更好，编译器的效率更高。

微指令（microcode），又称微码，是在CISC架构下，运行一些功能复杂的指令时，所分解一系列相对简单的指令。微指令的作用是机器指令与相关的电路实现分离，这样一来机器指令可以更自由的进行设计与修改，而不用考虑到实际的电路架构。与其他方式比较起来，使用微指令架构可以在降低电路复杂度的同时，建构出复杂的多步骤机器指令。撰写微指令一般称为微程序设计（microprogramming），而特定架构下的处理器实做中微指令有时会称为微程序（microprogram）。

现代的微指令通常由CPU工程师在设计阶段编写，并且存储在只读存储器（ROM, read-only-memory）或可编程逻辑数组（PLA, programmable logic array）中。它通常对普通程序员甚至是汇编语言程序员来说是不可见的，也是无法修改的。与机器指令不同的是，机器指令必须在一系列不同的处理器之间维持兼容性，而微指令只设计成在特定的电路架构下运行，成为特定处理器设计的一部分。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210806235750983.png" alt="image-20210806235750983" style="zoom:50%;" />

CISC执行复杂指令时，实际上是在执行一个微程序。这也带来两种指令集的一个差别，微程序的执行是不可被打断的，而RISC指令之间可以被打断，所以理论上RISC可更快响应中断。

2. 指令流水线

处理器当然有许多事情要做，但这些事情大都需要一系列步骤才能完成——从存储器取指令、译码、读/写操作数、移位、加减乘除，以及其他任何需要的操作。理想情况下，当前一个步骤完成时，后一个步骤应该紧随其后，中间不应该存在时间上的延迟。要是这样的话，我们手头上的绝大多数工作都应该能在瞬间完成，但是事实上却感觉不到这种情况的存在。处理器当然非常快，但它不是在孤立地工作，需要一大堆外围设备的配合，为它提供数据，遗憾的是这些东西都很慢。

论访问速度，由触发器组成的内存（SRAM）是最快的，一般为几纳秒。与之相比，动态存储器（DRAM）就差些，访问速度可能是几十纳秒，很大一部分原因在于它需要频繁地刷新，在此期间无法接待处理器的造访。但是，与SRAM相比，DRAM最大的优势在于它的高密度和低成本，使得我们可以花很少的钱就能买到一个大容量的内存。对于个人应用来说，这是一个很好的折中方案，既不会慢到无法忍受，同时又省了钱。问题是，处理器就很遭罪了，理想情况下只需要7个时钟周期的指令，可能实际上需要50个时钟周期才能完成，中间多出来的这些时钟周期，完全是为了等待内存而临时插入的：

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210807162858407.png" alt="image-20210807162858407" style="zoom: 67%;" />

顺序执行指令

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210807164558592.png" alt="image-20210807164558592" style="zoom: 67%;" />

使用流水线技术执行指令

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210807164658181.png" alt="image-20210807164658181" style="zoom: 67%;" />

第一个问题是，由于指令之间存在依赖关系，为了保证指令执行的正确性，要先弄清楚数据依赖性，必要时停止流水线，避免出错。

在一些高性能CPU中，会更进一步，动态排序有依赖关系的指令，最小化流水线的停工时间，这种执行方式叫做乱序执行或错序执行（out-of-order execution，OOE）。在这种方式中，处理器在一个由输入数据可用性所决定的顺序中执行指令，而不是由程序的原始数据所决定。因此可以避免因为获取下一条程序指令所引起的处理器等待，取而代之的处理下一条可以立即执行的指令。

第二个问题是，条件跳转指令会改变程序的执行流，它使得处理器无法确定后面的指令。

解决这个问题的方法是为处理器增加分支预测功能，通过为处理器增加额外的电路，来预测将要发生的跳转。分支预测正确即可继续执行，否则就要清空流水线。现代CPU的分支预测正确率超过90%。

3. 超标量体系结构

超标量（superscalar）CPU架构是指在一颗处理器内核中实行了指令级并发的一类并发运算。这种技术能够在相同的CPU主频下实现更高的CPU流量（throughput）。处理器的内核中一般有多个执行单元（或称功能单元），如算术逻辑单元、位移单元、乘法器等等。未实现超标量体系结构时，CPU在每个时钟周期仅执行单条指令，因此仅有一个执行单元在工作，其它执行单元空闲。超标量体系结构的CPU在一个时钟周期可以同时分派（dispatching）多条指令在不同的执行单元中被执行，这就实现了指令级的并行。超标量体系结构可以视作多指令流多数据流（Multiple Instruction Stream Multiple Data Stream，MIMD）。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210807173505209.png" alt="image-20210807173505209" style="zoom: 67%;" />

4. 多核心处理器

多核心处理器（Multi-core processor），又称多核微处理器，是在单个计算组件中加入两个或以上的独立实体中央处理单元（简称核心，Core）。这些核心可以分别独立地运行程序指令，利用并行计算的能力加快程序的运行速度。一般情况下，多核心处理器可以在每个核心分别独立物理封装的情况下进行多任务处理（线程级并发处理，Thread-Level Parallelism，TLP）。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210807173709694.png" alt="image-20210807173709694" style="zoom: 67%;" />

5. 高速缓存

除了流水线，另一个被用来平衡处理器和内存速度的手段是使用高速缓存技术，字面上的意思是速度很快的缓冲存储器。类似于蓄水池，这种技术基于计算机运行的一个特点——局部性。通俗地说，局部性的意思是，程序在被执行的过程中常常会访问最近刚刚访问过的数据，或者该位置附近的数据。

SRAM的优点是速度快，但是制造成本很高，通常不作为内存使用。不过，好的东西不能拥有全部，来一点点应该还是可以的。基于局部性的原理，可以在处理器和内存之间放置一小块SRAM，当处理器从一个新的内存地址开始执行时，将那一整片的东西都搬到这块SRAM中。这样一来，如果下次要访问的内容正好在SRAM中，就不用再到内存中去取，从而节省了时间。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210807175603959.png" alt="image-20210807175603959" style="zoom: 67%;" />

高速缓存有一个控制器，即图中所示的Cache控制器。平时，中央处理器送出地址，要从内存中取数据时，Cache控制器把该地址同高速缓存中的地址进行比较，以查明该数据是否在高速缓存中。如果要取的数据正好在高速缓存中，称为“缓存命中（CACHE HIT）”，处理器可以直接拿到数据。处理器从高速缓存中取得数据的时间通常很短，称为“命中时间”。如果数据不在高速缓存中，称为“缓存未命中（CACHE MISS）”。高速缓存不中是非常糟糕的，是最坏的情况。在这种情况下，处理器需要重新装载高速缓存（而不是硬着头皮去访问内存）。装载高速缓存也需要时间，即“不中惩罚”，这意味着执行一条指令需要更多的时间。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210807174719009.png" alt="image-20210807174719009" style="zoom:50%;" />

高速缓存是否能大幅度提升计算机的速度和性能，取决于命中的概率，也就是命中率。实际上，命中率受很多因素的影响，包括高速缓存的设计和软件的编写技巧。

高速缓存也可以在一些复杂运算中保存中间值。这导致缓存内容和内存中的内容不一致，为了同步数据，缓存中每块空间，都有一个特殊标记，称为“脏位（DIRTY BIT）”。当缓存满了而CPU又要装载缓存时，在清理缓存腾出空间之前，会先检查”脏位“。如果是”脏“的，在先把数据写回内存，再加载新内容。

#### 分层与抽象

首先应该明确，在计算机中有分层的概念，也就是说，计算机是一个大的组合物，由各个部分组合成一个系统。每个部分就是一层功能模块，各司其职，它只完成一定的工作，并将自己的工作结果（也就是输出）交给下一层的模块，这里的模块指的是各种外设、硬件。这样，各种工作成果不断累加，通过这种流水线式的上下游协作，便实现了所谓的系统。可见，系统就是各种功能组合到一起后，产生最终输出的组合物。

在计算机科学中，抽象化（Abstraction）是将资料与程序，以它的语义来呈现出它的外观，但是隐藏起它的实现细节。抽象化是用来减少程序的复杂度，使得程序员可以专注在处理少数重要的部分。一个电脑系统可以分割成几个抽象层（Abstraction layer），使得程序员可以将它们分开处理。

当我们专注于某个层次时，其控制器Controller负责控制流程，运用下层提供的服务Service完成相应的功能。其中不需要了解下层实现的细节，只需要知道下层Service的抽象接口。当Controller向更上层次提供服务时，也被抽象为Service。调用下层服务时，Controller是控制流程、发布指令者，而向更上层提供服务时，Controller是接受控制、执行指令者。

<img src="C:\Users\sunjxan\AppData\Roaming\Typora\typora-user-images\image-20210810144814142.png" alt="image-20210810144814142" style="zoom:67%;" />

#### CPU与外界交互

CPU在计算机系统中处于顶层，外界向其提供服务。首先要提供的就是读取和存储数据的服务，CPU通过数据总线、地址总线和控制总线三类总线完成读写数据。CPU使用其他芯片的服务，其他芯片根据传入的数据工作，而CPU自己控制从内存读取数据并据此完成工作，所以说CPU是计算机系统的大脑。

计算机可以接非常多的输入输出设备，比如键盘、鼠标、显示器、网卡、硬盘、打印机、音响等等，每个设备的用法和功能都不同，那操作系统是如何把这些输入输出设备统一管理的呢?为了屏蔽设备之间的差异，每个设备都有一个设备控制器，比如硬盘有硬盘控制器、显示器有视频控制器等。这些控制器都很清楚的知道对应设备的用法和功能，所以 CPU 是通过设备控制器来和设备打交道的。

<img src="https://pic1.zhimg.com/80/v2-b02440a38ff73eecdc930b319ea900d8_720w.jpg" alt="img" style="zoom: 67%;" />

设备控制器里有芯片，它可执行自己的逻辑，也有自己的寄存器，用来与 CPU 进行通信，比如：

- 通过写入这些寄存器，操作系统可以命令设备发送数据、接收数据、开启或关闭，或者执行某些其他操作。
- 通过读取这些寄存器，操作系统可以了解设备的状态，是否准备好接收一个新的命令等。

实际上，控制器是有三类寄存器，它们分别是**状态寄存器（Status Register）**、 **命令寄存器（Command Register）以及数据寄存器（Data Register）**，如下图：

<img src="https://pic4.zhimg.com/80/v2-9fbae6310151d0cb7c0b6582a8161dff_720w.jpg" alt="img" style="zoom: 80%;" />

这三个寄存器的作用：

- *数据寄存器*，CPU 向 I/O 设备写入需要传输的数据，比如要打印的内容是「Hello」，CPU 就要先发送一个 H 字符给到对应的 I/O 设备。
- *命令寄存器*，CPU 发送一个命令，告诉 I/O 设备，要进行输入/输出操作，于是就会交给 I/O 设备去工作，任务完成后，会把状态寄存器里面的状态标记为完成。
- *状态寄存器*，目的是告诉 CPU ，现在已经在工作或工作已经完成，如果已经在工作状态，CPU 再发送数据或者命令过来，都是没有用的，直到前面的工作已经完成，状态寄存标记成已完成，CPU 才能发送下一个字符和命令。

CPU 通过读写设备控制器中的寄存器控制设备，这可比 CPU 直接控制输入输出设备，要方便和标准很多。

另外， 输入输出设备可分为两大类 ：**块设备（Block Device）和字符设备（Character Device）**。

- *块设备*，把数据存储在固定大小的块中，每个块有自己的地址，硬盘、USB 是常见的块设备。
- *字符设备*，以字符为单位发送或接收一个字符流，字符设备是不可寻址的，也没有任何寻道操作，鼠标是常见的字符设备。

块设备通常传输的数据量会非常大，于是控制器设立了一个可读写的**数据缓冲区**。

- CPU 写入数据到控制器的缓冲区时，当缓冲区的数据囤够了一部分，才会发给设备。
- CPU 从控制器的缓冲区读取数据时，也需要缓冲区囤够了一部分，才拷贝到内存。

这样做是为了，减少对设备的频繁操作。

那 CPU 是如何与设备的控制寄存器和数据缓冲区进行通信的？存在两个方法：

1. 内存映射 I/O

除了RAM和ROM（装有系统BIOS），将某个外设的内存映射到一定范围的地址空间中，CPU通过地址总线访问该内存区域时会落到外设的内存中，这种映射让CPU访问外设的内存就如同访问主板上的物理内存一样。有的设备是这样做的，比如显卡，显卡是显示器的适配器，CPU不直接和显示器交互，它只和显卡通信。显卡上有片内存叫显存，它被映射到主机物理内存上的低端1MB的0xB8000～0xBFFFF。CPU访问这片内存就是访问显存，往这片内存上写字节便是往屏幕上打印内容。

2. 端口 I/O

CPU访问外设，就是访问IO接口，由IO接口将信息传递给另一端的外设，也就是说，CPU从来不知道有这些设备的存在，它只知道自己操作的IO接口。IO接口上面有一些寄存器，访问IO接口本质上就是访问这些寄存器，这些寄存器叫做端口。这些端口是IO接口提供的接口，IO接口电路也有自己的思维（系统），看到寄存器中写了什么就做出相应的反应。

#### I/O控制方式

在前面我知道，每种设备都有一个设备控制器，控制器相当于一个小 CPU，它可以自己处理一些事情，但有个问题是，当 CPU 给设备发送了一个指令，让设备控制器去读设备的数据，它读完的时候，要怎么通知 CPU 呢？

控制器的寄存器一般会有状态标记位，用来标识输入或输出操作是否完成。于是，我们想到第一种**轮询等待**的方法，让 CPU 一直查寄存器的状态，直到状态标记为完成，很明显，这种方式非常的傻瓜，它会占用 CPU 的全部时间。

那我们就想到第二种方法 —— **中断**，通知操作系统数据已经准备好了。我们一般会有一个硬件的**中断控制器**，当设备完成任务后触发中断到中断控制器，中断控制器就通知 CPU，一个中断产生了，CPU 需要停下当前手里的事情来处理中断。

另外，中断有两种，一种**软中断**，例如代码调用 `INT` 指令触发，一种是**硬件中断**，就是硬件通过中断控制器触发的。

但中断的方式对于频繁读写数据的磁盘，并不友好，这样 CPU 容易经常被打断，会占用 CPU 大量的时间。对于这一类设备的问题的解决方法是使用 **DMA（Direct Memory Access）** 功能，它可以使得设备在 CPU 不参与的情况下，能够自行完成把设备 I/O 数据放入到内存。那要实现 DMA 功能要有 「DMA 控制器」硬件的支持。

![img](https://pic1.zhimg.com/80/v2-cc208f80356d4b85fade3d542247d528_720w.jpg)

DMA 的工作方式如下：

- CPU 需对 DMA 控制器下发指令，告诉它想读取多少数据，读完的数据放在内存的某个地方就可以了；
- 接下来，DMA 控制器会向磁盘控制器发出指令，通知它从磁盘读数据到其内部的缓冲区中，接着磁盘控制器将缓冲区的数据传输到内存；
- 当磁盘控制器把数据传输到内存的操作完成后，磁盘控制器在总线上发出一个确认成功的信号到 DMA 控制器；
- DMA 控制器收到信号后，DMA 控制器发中断通知 CPU 指令完成，CPU 就可以直接用内存里面现成的数据了；

可以看到， CPU 当要读取磁盘数据的时候，只需给 DMA 控制器发送指令，然后返回去做其他事情，当磁盘数据拷贝到内存后，DMA 控制机器通过中断的方式，告诉 CPU 数据已经准备好了，可以从内存读数据了。仅仅在传送开始和结束时需要 CPU 干预。

#### 中断

中断（Interrupt）是指处理器接收到来自硬件或软件的信号，提示发生了某个事件，应该被注意，这种情况就称为中断。

通常，在接收到来自外围硬件（相对于中央处理器和内存）的异步信号，或来自软件的同步信号之后，处理器将会进行相应的硬件／软件处理。发出这样的信号称为进行中断请求（interrupt request，IRQ）。硬件中断导致处理器通过一个运行信息切换（context switch）来保存执行状态（以程序计数器和程序状态字等寄存器信息为主）；软件中断则通常作为CPU指令集中的一个指令，以可编程的方式直接指示这种运行信息切换，并将处理导向一段中断处理代码。

1. 8259A中断控制器

8259A中断控制器由两片8259A芯片级联组成，每个芯片有8个中断输入引脚，其中IRQ2被用来连接从芯片，所以一共可以支持15个中断号，这也就是早期采用8259A中断控制器只能使用15个外部中断的原因，使用8259A中断控制器的工作架构如下：

<img src="https://img2020.cnblogs.com/blog/659280/202104/659280-20210420144319612-1687748911.png" alt="img" style="zoom:80%;" />

每个外部设备连接一条中断线，当设备需要中断CPU时，通过这些中断线，发送中断请求。中断控制器感知到这些中断请求，会设置中断控制器中的中断请求寄存器的相应位为1，鉴于多个中断可能并发到达，中断控制器具备中断判优功能，当其选定一个中断作为当前响应中断时，会清除中断请求寄存器中的对应位，然后设置中断服务寄存器的某些位为1，表明CPU正在服务于某个中断请求。

另外8259A还有一个8位的中断屏蔽寄存器，每一位对应于一个中断线，当对应的位被设置后，表明要屏蔽这些中断。为了处理不同优先级的中断，中断控制器还有同一个优先权判决器，当一个中断到达时，判断到达的中断优先级和ISR中正在服务的中断优先级的大小，若高于正在服务的中断的优先级，需要打断当前中断的处理，转而处理新到达的中断请求，否则，不予理会。

CPU在执行当前指令的最后一个时钟周期去查询INTR引脚，若查询到中断请求信号有效，同时在系统开中断（即IF=1）的情 况下，CPU向发出中断请求的外设回送一个低电平有效的中断应答信号，作为对中断请求INTR的应答，系统自动进入中断响应周期（即中断响应指令的指令周期）。

2. 高级可编程中断控制器APIC

APIC由两部分组成：LOCAL APIC和IO APIC。LOCAL APIC和逻辑CPU绑定，它控制传递给逻辑处理器中断信号和产生IPI中断（这是处理器间中断，只用于多处理器情况）。当LOCAL APIC接收到一个中断信号，会通过某个发送协议把信号发送给处理器核心，具体可以通过一组被称之为local vector table 的APIC寄存器设置某个中断源的中断号。

<img src="https://images2015.cnblogs.com/blog/758933/201611/758933-20161118205939373-1659804228.png" alt="img" style="zoom:80%;" />

IO APIC其实是作为一个PCI设备挂载在PCI总线上，和传统的PIC相比，IO APIC最大的作用在于中断的分发，外部设备不直接连接在LOCAL APIC，而是连接在IO APIC,由IO APIC处理中断消息后发送给LOCAL APIC。IO APIC一般由24个中断管脚，每个管脚对应一个RTE，并且其各个管脚没有优先级之分，具体中断的优先级由其对应的向量决定，即前面所说的local vector table。每当IO APIC接收到一个中断消息，就根据其内部的PRT表格式化出一条中断消息，发送给LOCAL APIC。

#### 设备驱动

虽然设备控制器屏蔽了设备的众多细节，但每种设备的控制器的寄存器、缓冲区等使用模式都是不同的，所以为了屏蔽「设备控制器」的差异，引入了**设备驱动程序**。

<img src="https://pic4.zhimg.com/80/v2-d389de84bf1b9413f4eaad153a1973d3_720w.jpg" alt="img" style="zoom:80%;" />

设备控制器不属于操作系统范畴，它是属于硬件，而设备驱动程序属于操作系统的一部分，操作系统的内核代码可以像本地调用代码一样使用设备驱动程序的接口，而设备驱动程序是面向设备控制器的代码，它发出操控设备控制器的指令后，才可以操作设备控制器。

不同的设备控制器虽然功能不同，但是**设备驱动程序会提供统一的接口给操作系统**，这样不同的设备驱动程序，就可以以相同的方式接入操作系统。如下图：

![img](https://pic1.zhimg.com/80/v2-040aa44c1d775e05b424c709b8d96bc0_720w.jpg)

前面提到了不少关于中断的事情，设备完成了事情，则会发送中断来通知操作系统。那操作系统就需要有一个地方来处理这个中断，这个地方也就是在设备驱动程序里，它会及时响应控制器发来的中断请求，并根据这个中断的类型调用响应的**中断处理程序**进行处理。

通常，设备驱动程序初始化的时候，要先注册一个该设备的中断处理函数。

![img](https://pic4.zhimg.com/80/v2-ae6a76def666f927c0600afb1b4f9383_720w.jpg)

我们来看看，中断处理程序的处理流程：

1. 在 I/O 时，设备控制器如果已经准备好数据，则会通过中断控制器向 CPU 发送中断请求；
2. 保护被中断进程的 CPU 上下文；
3. 转入相应的设备中断处理函数；
4. 进行中断处理；
5. 恢复被中断进程的上下文；

#### 计算机系统

![800px-Motherboard_diagram.svg](D:\Desktop\800px-Motherboard_diagram.svg.png)



