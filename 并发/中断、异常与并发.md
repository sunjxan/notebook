[原网页](https://www.jianshu.com/p/fdab39431ee5)

## 1. 中断

### 1.1. 解释

何为中断？书本上的一种解释如下：

> 中断(interrupt)是一种使CPU挂起正在执行的程序而转去处理特殊事件的操作。

不严谨地说，中断就是“函数”，这种“函数”可以由当前程序调用，也可以由操作系统调用，或者由硬件调用，相当于“库函数”。

但，**中断比库函数级别更高**，库函数需要引入库才能调用，而中断可以不引入任何库直接调用。

而且，**当没有操作系统时，中断也可以调用**。

在汇编语言中，程序可以通过`int n`调用中断，`n`是中断号。

### 1.2. 中断向量表(Interrupt Vector Table，IVT)

在**实模式**下，当程序通过`int n`调用中断时，系统是如何找到对应的中断程序并跳转的呢？

在内存最低端的1KB空间中，存放着一个中断向量表。其中，每个中断向量占4个字节，顺序存放在中断向量表中，比如，0号中断向量在地址`0*4`处，1号中断向量在地址`1*4`处。

### 1.3. 中断向量

那什么是中断向量呢？

其实，中断向量就是中断处理程序的入口地址。4字节中，高两字节是入口地址的段值，低两字节是入口地址的偏移。

### 1.4. 中断处理程序

IA-32系列CPU能支持256种类型的中断(1KB即有256个中断向量)，分别编号为0255，即中断类型号，简称中断号。其中，前32个中断(031)保留给处理使用，剩余的可由用户(比如操作系统)自定义。

每个中断都有各自的作用，并且对应一个中断处理程序。比如，属于内部中断的0号中断，是出现除0时，执行相关操作；10号中断是显示I/O中断，提供给用户调用。

### 1.5. 中断响应过程

以**实模式下的IA－32系统CPU**为例，中断响应和返回过程，由硬件完成，步骤如下：

1. 根据`int n`指令取得中断号
2. 将标志寄存器值`flags`压栈
3. 关闭外部中断和单步中断(`IF`和`TF`标志位清0)
4. 中断返回地址的段值`cs`和偏移`ip`压栈
5. 根据中断号，从中断向量表中取得中断处理程序的入口地址
6. 跳转至中断处理程序
7. 执行中断处理程序......
8. 中断返回时，从栈中恢复`ip`,`cs`,`flags` 

可以看出，中断响应和函数调用过程十分相似。而存取寄存器(cs,ip,flags)的操作，也就是**上下文切换**。

### 1.6. 中断类型

- 内部中断：发生在CPU内部，也称软件中断。比如，0号除法出错中断，1号单步中断，用户调用`int n`指令引起的中断。
- 外部中断：发生在CPU外部，由硬件引起，也称硬件中断。
  - 可屏蔽中断：由`INTR`传给CPU，如果标志位`IF`为0，则CPU不响应。
  - 不可屏蔽中断：由`NMI`传入，要求CPU及时处理，比如电源掉电、存储器出错等。

## 2. 异常

### 2.1. 异常的由来

在早期的`Intel 8086/8088`微处理器中，并不区分异常和中断，统称为中断。所以，上述**中断内容**都是在 **Intel 8086 实模式**基础上的，而下述**异常内容**将在**操作系统保护模式**基础上。

从`80286`开始，`Intel`统一把**内中断**称为**异常/内部异常**，而把**外中断**称为**中断/外部中断**。

在CSAPP中，把外中断也纳入了异常的范畴。

当异常或中断发生时，正在执行的**逻辑控制流**被打断，CPU转而执行**异常处理程序**，从而引起**异常控制流**。

### 2.2. 异常的分类

- 故障：指令执行产生的意外事件，如页故障、除法出错等。返回原程序的当前指令。
- 陷阱：“预先安排”的异常，比如，系统调用(提供用户与操作系统内核交互的接口)、断点设置等。返回原程序的下一条指令。
- 终止：执行指令时发生的严重错误，比如CPU出现问题等。不返回原程序。

### 2.3. 中断描述符表(Interrupt Descriptor Table，IDT)

不同于实模式，IA-32保护模式，借助**中断描述符表**来存储异常处理程序或中断处理程序的入口地址，并且由`IDTR`寄存器来指定IDT表的位置。

中断描述表与中断向量表类似，共有256个表项，每个表项是一个8字节的**中断门描述符**、**陷阱门描述符**或**任务门描述符**。

(为什么总要取一些奇奇怪怪的名字呢？故意让人看不懂吗？不懂不懂)

`Linux`内核在系统初始化时，会设置好IDT中的每个表项。

## 3. 并发

中断与异常有着千丝万缕的关系，但并发又跟这两者有何关系呢？

### 3.1. 并发的本质

首先，我们必须意识到，平时遇见的并发(多个进程同时运行)，本质上是快速交替运行的进程(不考虑多CPU)。

而在某一个时刻，只能有一个程序在CPU运行，但由于各进程快速(毫秒级)交替运行，所以我们看起来**像是同时运行的**。

究其本质，并发，是由操作系统根据一个**定时器中断**，每过一会儿(xx毫秒)就帮我们切换运行程序，从而营造出来的**假象**。

### 3.2. 定时器中断

在实模式中，硬件**定时器**每隔55ms会发出一次中断请求，CPU接收到定时请求后，会转入8号定时器中断处理程序。

8号中断处理程序中，含有一条中断指令`int 1CH`，而1CH号中断处理程序并没有做任何工作，可以认为它只有一条中断返回指令。

如果我们将`1CH`中断处理程序设置为自定义的程序(将自定义程序的入口地址，填入中断向量表1CH*4地址处)，那么每过一段时间自定义程序便会被调用。

假如有主程序A和自定义的1CH中断处理程序B，那么A、B程序会相互切换执行，每过55ms执行B程序，然后中断返回执行A程序。

由于55ms肉眼无法察觉，所以我们会看到A、B程序同时运行的假象。

### 3.3. 浅析多进程并发

现在，我们将主程序A看作**操作系统**，程序B看作**进程切换程序**。

那么，我们可以很明朗地发现，只要在程序B中，不断保存、恢复进程的上下文(进程的寄存器等)，就可以实现进程的切换。

每过55ms(或者更久)执行程序B，切换运行进程，并跳转到切换后的进程执行。从而实现多进程并发运行。